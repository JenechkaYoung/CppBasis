#include <iostream>



int main()
{
    // Удобно рассматривать имя переменной как ссылку на адрес ячейки памяти
    int x = 5;                  // x имеет тип int
    x = 10;                     // при подстановки в левую часть оператора присваивания x имеет уже тип int& (lvalue)
    x + 10;                     // в большинстве других случаев x имеет тип int (rvalue)

    // Инициализировать неконстантную ссылку может только ссылка (lvalue)
    const int& cref = 5;
    // int& ref = 5;    -   ошибка
    int& ref = x;               // ref имеет тип int&
    int b = ref + 5;            // ref преобразуется в int

    // & преобразует ссылку (int&) в указатель (int*)
    int* px = &ref;
    // то есть, & не может преобразовать int (rvalue)
    // px = &(x+10);    -   ошибка

    // * преобразует указатель (int*) в ссылку (int&) (lvalue)
    ref = *px;
    *px = ref;

    // (expr1)[expr2] всегда эквивалентно *(expr1 + expr2)
    1[px];


    int arr[5];                 // arr имеет тип int TYPE[5]
                                // типу int TYPE[5] нельзя ничего присвоить
    arr + 1;                    // выражение имеет тип int* TYPE (arr неявно преобразуется из int (*)[5] в int*)
    &arr;                       // выражение имеет тип int (*TYPE)[5]
    &(arr[0]);                  // выражение имеет тип int* TYPE        =>  сравнить эти два выражения нельзя
    // &arr == &(arr[0]);   -   ошибка


    void fun1(int arr[3]);      // в объявлении и определении функции запись int arr[n] всегда преобразуется
                                // в int* arr.
                                // При этом указанный размер ни на что не влияет и можно передать массив любой длины
                                // или просто указатель
    fun1(arr);

    void fun2(int (&arr)[3]);   // однако если передавать указатель (ссылку) на массив, то в функцию можно передать
                                // только int (&)[3]

    // fun2(arr);   -   ошибка
    int arr3[3];
    fun2(arr3);


    // при статическом многомерном массиве выделяется непрерывный блок памяти и доступ к элементу из записи
    // x[2][3] (объявлен массив int x[5][5]) вычисляется как ((int*)x + 2 * 5 + 3)
}

void fun1(int* arr){
    std::cout << "Hello!\n";
}

void fun2(int (&arr)[3]){                   // при передаче массива как по ссылке, так и по указателю позволяет
    for( auto el : arr ) {                  // использовать аргумент как обычный статический массив
        std::cout << sizeof(arr) << "\n";
    }
}
